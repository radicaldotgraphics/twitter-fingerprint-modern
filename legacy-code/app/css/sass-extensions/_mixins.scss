
// @param {string} bp Breakpoint value. One of `xs, sm, md, lg`.
// @param {boolean} isMaxWidth By default, the media queries are mobile first,
//     so they use `min-width: __px`. By passing `true`, the mixin will subtract
//     one pixel from the breakpoint value and make it `max-width: __px`.
//
@mixin breakpoint($bp, $isMaxWidth: false) {
  $breakpoint: map-get($breakpoints, $bp);
  $media: if($isMaxWidth, 'max-width', 'min-width');

  @if $isMaxWidth {
    $breakpoint: $breakpoint - 1px;
  }

  @if map-has-key($breakpoints, $bp) {
    @media ($media: $breakpoint) {
      @content;
    }
  } @else {
    @warn "#{$bp} not recognized. Valid breakpoints: #{map-keys($breakpoints)}";
  }
}

@mixin breakpoints($min, $max) {
  $start: map-get($breakpoints, $min);
  $end: map-get($breakpoints, $max);

  @if map-has-key($breakpoints, $min) and map-has-key($breakpoints, $max) {
    $end: $end - 1px;
    @if $start > $end {
      @warn "Unreachable media query: #{$start} <--> #{$end}";
    } @else {
      // There should be no lower bound when the extra small breakpoint is used.
      // e.g. `@include breakpoints(xs, sm)` should be from 0 <--> 760, not 328 <--> 760.
      @if $min == "xs" {
        @media (max-width: $end) {
          @content;
        }
      } @else {
        @media (min-width: $start) and (max-width: $end) {
          @content;
        }
      }
    }
  } @else {
    @warn "#{$min} or #{$max} breakpoint not recognized. Valid breakpoints: #{map-keys($breakpoints)}";
  }
}

// Compiles all supplied properties in a map to css
@mixin get-properties($properties) {

  // Font Family
  @if map-has-key($properties, "font") {
    font-family: get-font-family(map-get($properties, "font"));
  }

  // Color
  @if map-has-key($properties, "color") {
    color: get-color("grays", map-get($properties, "color"));
  }

  // Font Size
  @if map-has-key($properties, "size") {
    font-size: px-rem(map-get($properties, "size"));
  }

  // Font Weight
  @if map-has-key($properties, "weight") {
    font-weight: map-get($properties, "weight");
  }

  // Text Transform
  @if map-has-key($properties, "transform") {
    text-transform: map-get($properties, "transform");
  }

  // Letter Spacing
  @if map-has-key($properties, "letter-spacing") {
    letter-spacing: map-get($properties, "letter-spacing");
  }

  // Line Height
  @if map-has-key($properties, "line-height") {
    line-height: px-rem(map-get($properties, "line-height"));
  }

  // Margin Bottom
  @if map-has-key($properties, "margin-bottom") {
    margin-bottom: px-rem(map-get($properties, "margin-bottom"));
  }
}

@mixin augmentHitArea($byPercent: 100%, $pseudo: 'after') {
  $isPercent: str-slice(inspect($byPercent), -1) == "%";
  $size: if($isPercent, 100% + $byPercent, $byPercent);
  $offset: if($isPercent, $byPercent / -2, $byPercent / -4);

  // Increase the hit area by 100% by placing a pseudo element behind the handle
  &::#{$pseudo} {
    content: '';
    position: absolute;
    // Having the hit area on top of the handle seemed to help Android a little. Was below it (-1)
    z-index: 1;
    top: $offset;
    left: $offset;
    display: block;
    width: $size;
    height: $size;

    // Uncomment to see the hit area
    // background-color: rgba(255, 255, 0, 0.3);
  }
}


@mixin keep-aspect() {
  position: relative;
  width: 100%;
  height: 0;
  overflow: hidden;
  padding-bottom: 100%;
}

@mixin aspect($width, $height) {
  padding-bottom: percentage($height / $width);
}

@mixin no-aspect() {
  height: auto;
  padding-bottom: 0;
}


// Fill the parent using absolute positioning
@mixin fill-parent() {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}


// A ghost element used to vertically center something
// http://css-tricks.com/centering-in-the-unknown/
@mixin ghost( $child: 'ghost-center' ) {
  font-size: 0;
  height: 100%;

  &:before {
    content: '';
    display: inline-block;
    vertical-align: middle;
    width: 0;
    height: 100%;
  }

  .#{$child} {
    display: inline-block;

    // For Firefox...
    max-width: 100%;
    max-height: 100%;

    // Yeya!
    vertical-align: middle;

    // Because the parent has a font-size of 0.
    font-size: 16px;
    font-size: 1rem;
  }
}


// Clearfix
// --------
// For clearing floats like a boss h5bp.com/q
@mixin clearfix {
  &::before,
  &::after {
    display: table;
    content: "";
  }
  &::after {
    clear: both;
  }
}

// Text overflow
// -------------------------
// Requires inline-block or block for proper styling
@mixin text-overflow($nowrap: true) {
  overflow: hidden;
  text-overflow: ellipsis;
  @if ( $nowrap ) {
    white-space: nowrap;
  }
}


@mixin font-smooth($smooth: true) {
  @if $smooth {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  @else {
    -webkit-font-smoothing: subpixel-antialiased;
    -moz-osx-font-smoothing: auto;
  }
}

// Placeholder text
// -------------------------
@mixin placeholder($color: red, $smooth: false) {
  &:-moz-placeholder {
    color: $color;
    @if $smooth {
      @include font-smooth();
    }
  }
  &:-ms-input-placeholder {
    color: $color;
    @if $smooth {
      @include font-smooth();
    }
  }
  &::-webkit-input-placeholder {
    color: $color;
    @if $smooth {
      @include font-smooth();
    }
  }
}


// Promoting layers can alleviate many animation issues, but also be
// aware that having too many layers will cause performance issues.
// http://jankfree.org/
//
// A replacement for this is in the works. http://aerotwist.com/blog/bye-bye-layer-hacks/
// Spec: http://tabatkins.github.io/specs/css-will-change/
// Chrome ticket: http://crbug.com/313532
// Firefox ticket: https://bugzilla.mozilla.org/show_bug.cgi?id=940842
@mixin layer-promote() {
  -webkit-transform: translateZ(0);
          transform: translateZ(0);
}


@mixin background-cover() {
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center center;
}


